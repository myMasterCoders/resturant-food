import {
  DEFAULT_OPTIONS,
  parseCookieChunk,
  splitCookiesString
} from "./chunk-H3JIC3FI.js";
import {
  toArray
} from "./chunk-OAZLYBJA.js";
import {
  isFunction
} from "./chunk-CQJCSTBU.js";
import {
  isEmpty
} from "./chunk-ED5RUP25.js";
import {
  isObject
} from "./chunk-XUWL4VKZ.js";
import {
  isArray
} from "./chunk-UDVSPJHY.js";
import {
  isString
} from "./chunk-RUB2ELNH.js";

// src/cookies/parse-response-cookie/parse-response-cookie.ts
var parseResponseCookie = (input, userOptions) => {
  const options = { ...DEFAULT_OPTIONS, ...userOptions };
  if (isEmpty(input)) {
    return options.returnType === "array" ? [] : {};
  }
  const setCookieValue = toArray((() => {
    if (isString(input))
      return splitCookiesString(input);
    if (isArray(input))
      return input.reduce((acc, value) => [...acc, ...splitCookiesString(value)], []);
    if (isObject(input) && "headers" in input) {
      if (isFunction(input.headers.getSetCookie))
        return splitCookiesString(input.headers.getSetCookie());
      if ("set-headers" in input.headers) {
        return splitCookiesString(input.headers["set-cookie"]) ?? "";
      }
      const key = Object.keys(input.headers).find((header) => header.toLowerCase() === "set-cookie");
      if (key && key in input.headers) {
        return splitCookiesString(input.headers[key]);
      }
      return "";
    }
    return "";
  })()).filter(Boolean);
  return options.returnType === "array" ? setCookieValue.map((chunk) => {
    return parseCookieChunk(chunk, options.decodeValues);
  }).filter(Boolean) : setCookieValue.reduce((acc, chunk) => {
    const cookie = parseCookieChunk(chunk, options.decodeValues);
    if (!cookie)
      return acc;
    acc[cookie.name] = cookie;
    return acc;
  }, {});
};

export {
  parseResponseCookie
};
