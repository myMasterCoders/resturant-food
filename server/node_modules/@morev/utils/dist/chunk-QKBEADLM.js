import {
  isUndefined
} from "./chunk-F45GO7K2.js";
import {
  isInteger
} from "./chunk-4W3EM56D.js";
import {
  isDate
} from "./chunk-4GTX7FBA.js";
import {
  EN_DATETIME_REG_EXP,
  ISO_DATETIME_REG_EXP,
  RU_DATETIME_REG_EXP,
  createDateFromTokens,
  prefixedDateMethodsFactory
} from "./chunk-WI7PHIEY.js";

// src/dates/parse-date/parse-date.ts
var tokensFromDate = (date, utc) => {
  if (!date)
    return null;
  const get = prefixedDateMethodsFactory("get", utc);
  date.setUTCMinutes(date.getUTCMinutes() + (/* @__PURE__ */ new Date()).getTimezoneOffset());
  const year = date[get("FullYear")]();
  const month = date[get("Month")]();
  const day = date[get("Date")]();
  const hours = date[get("Hours")]();
  const minutes = date[get("Minutes")]();
  const seconds = date[get("Seconds")]();
  const milliseconds = date[get("Milliseconds")]();
  return { year, month, day, hours, minutes, seconds, milliseconds };
};
var DEFAULT_OPTIONS = { utc: false };
var parseDate = (input, userOptions) => {
  const options = { ...DEFAULT_OPTIONS, ...userOptions };
  if (isDate(input)) {
    if (!isDate(input, true))
      return null;
    const year = input.getFullYear();
    const month = input.getMonth();
    const day = input.getDate();
    const hours = input.getHours();
    const minutes = input.getMinutes();
    const seconds = input.getSeconds();
    const milliseconds = input.getMilliseconds();
    return tokensFromDate(
      createDateFromTokens({ year, month, day, hours, minutes, seconds, milliseconds }),
      options.utc
    );
  }
  if (isInteger(input)) {
    return tokensFromDate(new Date(input), options.utc);
  }
  let match = input.match(ISO_DATETIME_REG_EXP);
  if (match) {
    const [
      year,
      month,
      day,
      hours,
      minutes,
      seconds,
      milliseconds,
      offset
    ] = match.slice(1).map((part, index) => {
      if (isUndefined(part))
        return 0;
      if (index === 1)
        return Number(part) - 1;
      if (index === 7) {
        const [sign, offsetString] = [part[0], part.slice(1)];
        const offset2 = (() => {
          if (offsetString.length === 2) {
            return Number(offsetString) * 60;
          }
          if (offsetString.length === 4) {
            return Number(offsetString.slice(0, 2)) * 60 + Number(offsetString.slice(2));
          }
          return Number(offsetString.slice(0, 2)) * 60 + Number(offsetString.slice(3));
        })();
        return sign === "+" ? offset2 : -offset2;
      }
      return Number(part);
    });
    return tokensFromDate(
      createDateFromTokens({ year, month, day, hours, minutes, seconds, milliseconds, offset }),
      options.utc
    );
  }
  match = input.match(RU_DATETIME_REG_EXP);
  if (match) {
    const [
      day,
      month,
      year,
      hours,
      minutes,
      seconds,
      milliseconds
    ] = match.slice(1).map((part, index) => {
      if (isUndefined(part))
        return 0;
      if (index === 1)
        return Number(part) - 1;
      return Number(part);
    });
    return tokensFromDate(
      createDateFromTokens({ year, month, day, hours, minutes, seconds, milliseconds }),
      options.utc
    );
  }
  match = input.match(EN_DATETIME_REG_EXP);
  if (match) {
    const [
      month,
      day,
      year,
      hours,
      minutes,
      seconds,
      milliseconds
    ] = match.slice(1).map((part, index) => {
      if (isUndefined(part))
        return 0;
      if (index === 0)
        return Number(part) - 1;
      return Number(part);
    });
    return tokensFromDate(
      createDateFromTokens({ year, month, day, hours, minutes, seconds, milliseconds }),
      options.utc
    );
  }
  return null;
};

export {
  parseDate
};
