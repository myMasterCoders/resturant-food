import {
  mergeObjects
} from "./chunk-SYYF6SU6.js";
import {
  isInteger
} from "./chunk-4W3EM56D.js";

// src/numbers/format-bytes/format-bytes.ts
var REFERENCE_TABLE = {
  metric: [
    { from: 0, to: 1e3, prefix: "b" },
    { from: 1e3, to: 1e6, prefix: "k" },
    { from: 1e6, to: 1e9, prefix: "m" },
    { from: 1e9, to: 1e12, prefix: "g" },
    { from: 1e12, to: 1e15, prefix: "t" },
    { from: 1e15, to: 1e18, prefix: "p" },
    { from: 1e18, to: 1e21, prefix: "e" },
    { from: 1e21, to: 1e24, prefix: "z" },
    { from: 1e24, to: 1e27, prefix: "y" }
  ],
  IEC: [
    { from: 0, to: 1024 ** 1, prefix: "b" },
    { from: 1024 ** 1, to: 1024 ** 2, prefix: "k" },
    { from: 1024 ** 2, to: 1024 ** 3, prefix: "m" },
    { from: 1024 ** 3, to: 1024 ** 4, prefix: "g" },
    { from: 1024 ** 4, to: 1024 ** 5, prefix: "t" },
    { from: 1024 ** 5, to: 1024 ** 6, prefix: "p" },
    { from: 1024 ** 6, to: 1024 ** 7, prefix: "e" },
    { from: 1024 ** 7, to: 1024 ** 8, prefix: "z" },
    { from: 1024 ** 8, to: 1024 ** 9, prefix: "y" }
  ]
};
var UNITS_DEFAULTS = {
  metric: {
    b: "B",
    k: "kB",
    m: "MB",
    g: "GB",
    t: "TB",
    p: "PB",
    e: "EB",
    z: "ZB",
    y: "YB"
  },
  IEC: {
    b: "B",
    k: "KiB",
    m: "MiB",
    g: "GiB",
    t: "TiB",
    p: "PiB",
    e: "EiB",
    z: "ZiB",
    y: "YiB"
  }
};
var DEFAULT_OPTIONS = {
  precision: 1,
  to: "auto",
  trimZeros: true,
  mode: "metric",
  toString: (value, valueAsString, unit, isInteger2) => `${valueAsString} ${unit}`
};
var _options = /* @__PURE__ */ new WeakMap();
var FormatBytes = class {
  /**
   * The calculated value.
   */
  value;
  /**
   * The calculated value in string form with needed precision.
   */
  valueAsString;
  /**
   * Calculated unit of value.
   */
  unit;
  /**
   * Whether the value is an integer number. \
   * Mostly used for `i18n` purposes.
   */
  isInteger;
  constructor(bytes, customOptions) {
    if (!isInteger(bytes))
      bytes = 0;
    const options = mergeObjects(DEFAULT_OPTIONS, customOptions);
    _options.set(this, options);
    const referenceTable = REFERENCE_TABLE[options.mode];
    const entry = options.to === "auto" ? referenceTable.find((e) => bytes >= e.from && bytes < e.to) ?? referenceTable[0] : referenceTable.find((i) => i.prefix === options.to) ?? referenceTable[0];
    const { from, prefix } = entry;
    const unitsReferenceTable = mergeObjects(UNITS_DEFAULTS, options.customUnits);
    const unit = unitsReferenceTable[options.mode][prefix];
    let value = bytes / from;
    value = Number.isFinite(value) ? value : bytes;
    let valueAsString = value.toFixed(options.precision);
    value = parseFloat(valueAsString);
    if (options.trimZeros) {
      value = parseFloat(valueAsString);
      valueAsString = value.toString();
    }
    const isInteger2 = isInteger(value);
    this.value = value;
    this.valueAsString = valueAsString;
    this.unit = unit;
    this.isInteger = isInteger2;
  }
  toString() {
    const { value, valueAsString, unit, isInteger: isInteger2 } = this;
    const options = _options.get(this);
    return options.toString(value, valueAsString, unit, isInteger2);
  }
};
var formatBytes = (bytes, customOptions) => new FormatBytes(bytes, customOptions);
var formatBytesRu = (bytes, _customOptions) => {
  const customOptions = mergeObjects({
    // Not sure actually, it's not reglamented ¯\_(ツ)_/¯
    customUnits: {
      metric: {
        b: "\u0411",
        k: "\u041A\u0411",
        m: "\u041C\u0411",
        g: "\u0413\u0411",
        t: "\u0422\u0411",
        p: "\u041F\u0411",
        e: "\u0415\u0411",
        z: "\u0417\u0411",
        y: "\u0418\u0411"
      },
      IEC: {
        b: "\u0411",
        k: "\u041A\u0431",
        m: "\u041C\u0431",
        g: "\u0413\u0431",
        t: "\u0422\u0431",
        p: "\u041F\u0431",
        e: "\u0415\u0431",
        z: "\u0417\u0431",
        y: "\u0418\u0431"
      }
    }
  }, _customOptions);
  return new FormatBytes(bytes, customOptions);
};

export {
  formatBytes,
  formatBytesRu
};
